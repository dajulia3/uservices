{"name":"barinek/uservices","tagline":"Microservices and the Application Continuum","body":"### Introduction\r\n\r\nI thought I'd finally describe one of my favorite topics on application architecture; how to evolve an application over time. I've been thinking about writing this article for a while however, it's been slightly hard to effectively write a concrete example that captures all the decisions that go into writing large, distributed systems. More important, it's been even harder to craft a distributed example that evolves over time.\r\n\r\nI've recently worked on the below diagram, the application continuum, that attempts to describe the evolution of an application starting from a flat directory structure and then evolving to several applications and components.\r\n\r\n![](https://raw.githubusercontent.com/barinek/uservices/master/evolve.png)\r\n\r\nProjects could start anywhere on the continuum - typically driven by the amount of knowledge one knows about an application or set of applications. The less knowledge, the further left. The more knowledge, the further right. I've noticed that most app developers, including myself, tend to start somewhere in the middle of the continuum.\r\n\r\n<i>The continuum is language agnostic and applies to any modern programming language.</i>\r\n\r\nWhy is all this interesting? Isn't this just an opinionated way to organize a code base?\r\n\r\nThe architecture is an approach that attempts to continually reduce the cost of change overtime by providing developers and product owners the ability to use and reuse components withing a given code base to both pivot existing products and easily create new ones. It's an architecture that embraces change.\r\n\r\n### Project Structure\r\n\r\nI've used a series of Git commit tags to illustrate each steps.\r\n\r\n```\r\ngit tag -ln\r\n\r\nv1              First commit\r\nv2              Functional groups\r\nv3              Feature groups\r\nv4              Components\r\nv5              Services\r\n```\r\n\r\nI've chosen Pivotal Tracker as it has moved through a similar evolution over the past fews years. While I'm not using the actual Tracker code base (it's actually in Ruby), I've penciled in a few key epic features - Allocations, Backlog Management, and Time Tracking.\r\n\r\nNote - I've focused on the back-end development although, there's no reason you couldn't take a similar approach for the front end work. The project also includes only a few dependencies (Jetty and Jackson) and resides within a single Git repository.\r\n\r\n###  (v1) First commit\r\n\r\nThe v1 tag starts with a flat directory structure. While it's slightly naive to start far left on the continuum, I wanted to demonstrate that this would be a reasonable starting point having made no decisions around architecture. No groupings, no components, no services. Just a single, flat directory with class files.\r\n\r\n###  (v2) Functional groups\r\n\r\nv2 moves classes into Models, Controllers, Data Access Layer, and Utilities directories. I've noticed this directory structure (MVC) over the years in many popular frameworks although, I've found that as your application grows, as they all do, a change to a small feature tends to drive changes through your entire code base. This becomes increasingly painful when class dependencies are not fully understood - typically the result of accidental design versus intentional design.\r\n\r\n###  (v3) Feature groups\r\n\r\nTodo\r\n\r\n###  (v4) Components\r\n\r\nTodo\r\n\r\n###  (v5) Services\r\n\r\nTodo\r\n\r\n###  Summary\r\n\r\nTodo\r\n\r\nThanks! (@barinek) and thanks to () for the copy edit!\r\n","google":"UA-61007704-1","note":"Don't delete this file! It's used internally to help with page regeneration."}